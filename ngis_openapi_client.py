# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NgisOpenApiClient
                                 A QGIS plugin
 Plugin for nedlasting av data fra NGIS OpenAPI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-10-26
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Norconsult Informasjonssystemer AS
        email                : post@nois.no
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QTextCodec, QDate, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QPushButton, QMessageBox, QInputDialog
from qgis.utils import plugins
from qgis.core import (
    QgsProject,
    QgsPathResolver,
    QgsVectorLayer,
    QgsOgcUtils,
    QgsFeature,
    QgsJsonUtils,
    QgsJsonExporter,
    QgsAuthManager,
    QgsWkbTypes,
    QgsSettings,
    QgsDefaultValue,
    QgsFieldConstraints,
    QgsEditorWidgetSetup,
    QgsCoordinateReferenceSystem,
    QgsMessageLog,
    QgsFeatureRequest,
    QgsProcessingContext,
    QgsTaskManager,
    QgsTask,
    QgsProcessingAlgRunnerTask,
    Qgis,
    QgsProcessingFeedback,
    QgsApplication,
    QgsMessageLog,
    QgsField,
    QgsGeometry,
    QgsVectorLayerUtils
)


import json
import uuid
from .login import NgisOpenApiClientAuthentication
from .http_client import NgisHttpClient
import requests
from .ngis_openapi_client_aux import *
from .ngis_openapi_client_xsd_parser import *
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ngis_openapi_client_dialog import NgisOpenApiClientDialog
from .ngis_openapi_client_input_dialog import NgisInputTypeDialog
from xml.dom import minidom
import os.path
import re
from osgeo import ogr


class NgisOpenApiClient:
    """QGIS Plugin Implementation."""
    
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'NgisOpenApiClient_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NGIS-OpenAPI')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.dataset_dictionary = {}
        self.feature_type_dictionary = {}
        self.layer_dictionary = {}
        self.affected_features = {}
        self.client = None
        self.xsd = []
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('NgisOpenApiClient', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ngis_openapi_client/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'NGIS-OpenAPI Test'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NGIS-OpenAPI Test'),
                action)
            self.iface.removeToolBarIcon(action)

    def handle_login(self):
        auth = NgisOpenApiClientAuthentication()
        configId = self.dlg.mAuthConfigSelect.configId()
        url, username, password = auth.getConfig(configId)
        if not username:
            self.dlg.statusLabel.setText("Autentisering mislyktes")
            return
        self.client = NgisHttpClient(url, username, password) 

        try:
            datasets = self.client.getAvailableDatasets()
        except Exception as e:
            error = ApiError("Kunne ikke hente datasett", "Utlisting av datasett resulterte i en feil", e)  
            self.iface.messageBar().pushMessage(error.title, error.detail, error.show_more, level=2, duration=10)
            return 
        
        if len(datasets) == 0:
            self.dlg.statusLabel.setText("Ingen datasett tilgjengelig")
            return
        
        self.dataset_dictionary = {dataset["name"]:dataset["id"] for dataset in datasets}
        
        names = [dataset['name'] for dataset in datasets]
        self.dlg.mComboBox.addItems(names)

        self.dlg.mComboBox.setEnabled(True)
        self.dlg.logInButton.setEnabled(False)
        self.dlg.logOutButton.setEnabled(True)
        self.dlg.addLayerButton.setEnabled(True)
        self.dlg.mAuthConfigSelect.setEnabled(False)
        self.dlg.statusLabel.setText("")
        # Remember login method
        s = QgsSettings()
        s.setValue("ngisopenapi/auth_method_id", configId)
        return

    def handle_logout(self):
        self.dlg.mComboBox.clear()
        self.dlg.logInButton.setEnabled(True)
        self.dlg.logOutButton.setEnabled(False)
        self.dlg.addLayerButton.setEnabled(False)
        self.dlg.mAuthConfigSelect.setEnabled(True)
        self.dlg.mComboBox.setEnabled(False)
        self.client = None

    def create_group(self, name):
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(name)
        if not group:
            group = root.insertGroup(0, name)
        return group

    def handle_add_layer(self):
        """Create a new layer by name (rev_lyr)"""

        slds = self.get_sld()

        selected_name = self.dlg.mComboBox.currentText()
        selected_id = self.dataset_dictionary[selected_name]
        
        # Group name equals selected dataset name
        group_kodelister = self.create_group("Kodelister")
        group_kodelister.setExpanded(0)
        group = self.create_group(selected_name)
        

        # Get metadata and features from NgisOpenAPI
        try:
            metadata_from_api = self.client.getDatasetMetadata(selected_id)

            #resp = requests.get(metadata_from_api.schema_url)
            resp = requests.get('http://skjema.geonorge.no/SOSI/produktspesifikasjon/Havnedata/2.0/Havnedata.xsd', verify=False)
            #resp = requests.get('https://havnedata.blob.core.windows.net/skjema/Havnedata_testdemo.xsd', verify=False)

            self.xsd = parseXSD(resp.content)
            #raise Exception()
            #metadata_from_api.bbox['ur'] = [336509.55, 6578691.58]
            #metadata_from_api.bbox['ll']=[270083.13, 6522356.34]

            epsg = metadata_from_api.crs_epsg
            features_from_api = self.client.getDatasetFeatures(metadata_from_api.id, metadata_from_api.bbox, epsg)
        except Exception as e:
            error = ApiError("Nedlasting av data mislyktes", "Kunne ikke laste ned datasett", e)  
            self.iface.messageBar().pushMessage(error.title, error.detail, error.show_more, level=2, duration=10)
            return 
        crs_from_api = features_from_api['crs']['properties']['name']
        features_by_type = {}
        
        # Extract features from GeoJSON into dictionary
        for feature in features_from_api['features']:
            feature_type = feature['properties']['featuretype']
            features_by_type.setdefault(feature_type, []).append(feature)
        
        features_from_api['features'] = None



        for typeNavn, typeVerdi in self.xsd.items():
            for attrNavn, attrVerdi in typeVerdi.items():
                if (attrVerdi.type == 'enum' and attrVerdi.maxOccurs > 1):
                    vector_names = [l.name() for l in QgsProject().instance().mapLayers().values() if isinstance(l, QgsVectorLayer)]
                    if attrNavn in vector_names: continue

                    lyr = QgsVectorLayer('NoGeometry?crs=EPSG:4326&field=Verdi:string(40,0)', f'{attrNavn}', "memory")
                    lyr.setCustomProperty("skipMemoryLayersCheck", 1) #13012022
                    lyr.startEditing()
                    l_d = lyr.dataProvider()
                    fields = QgsFields()
                    fields.append(QgsField('Verdi', QVariant.String, '', 254, 0))
                    
                    for val in attrVerdi.values:
                        fet = QgsFeature()
                        fet.setFields(fields)
                        fet['Verdi']=val['value']
                        l_d.addFeature(fet)


                    lyr.commitChanges()
                    QgsProject.instance().addMapLayer(lyr, False)
                    group_kodelister.addLayer(lyr)
        layers = {}                    

        for feature_type, features_list in features_by_type.items():
            # Create a new GeoJSON object containing a single featuretype
            features_dict = features_from_api.copy()
            features_dict['features'] = features_list

            features_json = json.dumps(features_dict, ensure_ascii=False) 
            
            # Identify fields and features from GeoJSON
            codec = QTextCodec.codecForName("UTF-8")   
            fields = QgsJsonUtils.stringToFields(features_json, codec)
            newFeatures = QgsJsonUtils.stringToFeatureList(features_json, fields, codec)

            # If different geometry types are identified, separate them into individual layers
            geometry_dict = {}
            if newFeatures:   
                for feature in newFeatures:

                    featuretype = feature.attribute('featuretype')
                    geom_type = feature.geometry()
                    geom_type = QgsWkbTypes.displayString(int(geom_type.wkbType()))
                    if geom_type not in geometry_dict:
                        geometry_dict[geom_type] = {}
                    if featuretype not in geometry_dict[geom_type]:
                        geometry_dict[geom_type][featuretype] = []
                    
                    geometry_dict[geom_type][featuretype].append(feature)

            for geom_type, feature_types in geometry_dict.items():
                for feature_type, features in feature_types.items():
                    lyr = QgsVectorLayer(f'{geom_type}?crs={crs_from_api}', f'{feature_type}-{geom_type}', "memory")
                    #lyr = QgsVectorLayer(f'{geom_type}?crs=EPSG:25832', f'{feature_type}-{geom_type}', "memory") #TODO Remove
                    QgsProject.instance().addMapLayer(lyr, False)
                    
                    lyr.startEditing()
                    
                    add_fields_to_layer(lyr, fields, feature_type, self.xsd)
                    print(f'{geom_type}?crs={crs_from_api}', f'{feature_type}-{geom_type}')   
                    lyr.commitChanges()
                    l_d = lyr.dataProvider()
                    lyrfields = lyr.fields()

                    for feature in features:
                        fet = QgsFeature()
                        fet.setGeometry(feature.geometry())

                        attributes = feature.attributes()
                        newDict = {}
                        for idx, attribute in enumerate(attributes):
                            xsd_def = self.xsd[feature_type].get(fields.at(idx).name(), None)
                            
                            oldfield = fields.at(idx)
                            if xsd_def and feature.attributes()[idx] != None and xsd_def.type == "enum" and xsd_def.maxOccurs > 1:
                                vals = feature.attributes()[idx][3:-1]
                                
                                if isinstance(vals, list) == False:
                                    vals = feature.attributes()[idx][3:-1].split(",")
                                
                                vals = ','.join(vals)
                                newDict[oldfield.name()] = f'{{{vals}}}'
                                
                            else:
                                try:
                                    obj = json.loads(attribute)
                                    for key, value in obj.items():
                                        newDict[key] = value
                                except:
                                    newDict[oldfield.name()] = feature.attributes()[idx]

                        fieldOrder = {}
                        fet.initAttributes(len(lyrfields))
                        for fieldName in newDict.keys():
                            newIdx = lyrfields.indexFromName(fieldName)
                            fieldOrder[fieldName] = newIdx
                            print(f'{newIdx} - {newDict[fieldName]}')
                            try:
                                fet.setAttribute(newIdx, newDict[fieldName])
                            except Exception as e:
                                print(e)
                        l_d.addFeature(fet)

                    
                    # update the extent of rev_lyr
                    lyr.updateExtents()
                    # save changes made in 'rev_lyr'
                    lyr.commitChanges()
                    layers[lyr.name()] = lyr
                    
                   
                    #lyr.committedFeaturesAdded.connect(self.handleCommitedAddedFeatures)
                    #lyr.committedFeaturesRemoved.connect(self.handleCommittedFeaturesRemoved)
                    #lyr.featuresDeleted.connect(self.handleDeletedFeatures)
                    #lyr.committedGeometriesChanges(self.ee)
                    
                    lyr.beforeCommitChanges.connect(self.handle_before_commitchanges)
                    lyr.featureAdded.connect(self.handle_feature_added)
                    lyr.geometryChanged.connect(self.handle_geometry_change)

                    if feature_type in slds:
                        lyr.loadSldStyle(slds[feature_type])

                    self.dataset_dictionary[lyr.id()] = selected_id
                    self.feature_type_dictionary[lyr.id()] = feature_type
            
        for layername in sorted(list(layers.keys())):
            group.addLayer(layers[layername])

    def get_sld(self):
        sld_dict = {}
        folder_name = f"{os.path.dirname(__file__)}/styles"
        for filename in os.listdir(folder_name):
            full_path = f"{folder_name}/{filename}"
            sld = minidom.parse(full_path)
            styled_layer_descriptor = sld.getElementsByTagName('StyledLayerDescriptor')
            if len(styled_layer_descriptor) == 1:
                named_layers = styled_layer_descriptor[0].getElementsByTagName('NamedLayer')
                for named_layer in named_layers:
                    for child in named_layer.childNodes:
                        if child.localName == "Name":
                            name = child.firstChild.nodeValue
                            sld_dict[name] = full_path
                            break
        return sld_dict

    def handle_feature_added(self, fid):
        layer = self.iface.activeLayer()
        added_feature = layer.getFeature(fid)

        #ignore commited features
        if added_feature.id() > 0: 
            return

        #Polygon
        if added_feature.geometry().type() == 2:
            new_feature = self.feature_to_geojson(layer, added_feature)
            new_feature['update'] = {"action":"Create"}
            
            lokalid = str(uuid.uuid4())
            added_feature.setAttribute('lokalid', lokalid)
            layer.updateFeature(added_feature)

            new_feature["properties"]["identifikasjon"]["lokalId"] = lokalid

            url = 'https://ngis-felleskomponent-test.azurewebsites.net/createGeometry'
            body = {'feature': new_feature}

            x = requests.post(url, json = body)

            affected_features = json.loads(x.text)

            for feature in affected_features["affectedFeatures"]:
                self.affected_features[feature['properties']['identifikasjon']['lokalId']] = feature

            options = list(self.feature_type_dictionary.values())
            dialog = NgisInputTypeDialog(options)

            #TODO Fix
            avgrensingFeature = affected_features["affectedFeatures"][1]

            if dialog.ok:
                layerName = next(key for key, value in self.feature_type_dictionary.items() if value == dialog.item)
                lineLayer = QgsProject.instance().mapLayers()[layerName]
                lineLayer.startEditing()

                geom = ogr.CreateGeometryFromJson(json.dumps(avgrensingFeature['geometry']))
                geom = QgsGeometry.fromWkt(geom.ExportToWkt())

                dataProvider = lineLayer.dataProvider()
                #elem = QgsFeature()
                #elem.setGeometry(geom)

                feat = QgsVectorLayerUtils.createFeature(lineLayer, geom, {}, lineLayer.createExpressionContext() )

                
                feat.setAttribute('lokalid', avgrensingFeature['properties']['identifikasjon']['lokalId'])
                lineLayer.updateFeature(feat)

                tbl = self.iface.openFeatureForm(lineLayer, feat, False)
                if tbl == True:
                    dataProvider.addFeature(feat)
                    lineLayer.endEditCommand()
                
                lineLayer.addFeature(feat)


            print("Hallo")

    def handle_geometry_change(self, fid, geometry):
        print("geometryChanged")
        
        layer = self.iface.activeLayer()
        added_feature = layer.getFeature(fid)

    def handle_before_commitchanges(self):
        
        layer = self.iface.activeLayer()

        if layer.editBuffer():
            ids_deleted = layer.editBuffer().deletedFeatureIds()
            features_deleted = layer.dataProvider().getFeatures(QgsFeatureRequest().setFilterFids(ids_deleted))
            features_added = layer.editBuffer().addedFeatures()
            changed_geometries = layer.editBuffer().changedGeometries()
            changed_attribute_values = layer.editBuffer().changedAttributeValues()

            try:
                features = {}
                features.update(self.handle_committed_features_removed(layer, features_deleted))
                features.update(self.handle_committed_features_added(layer, features_added))
                features.update(self.handle_changed_values(layer, changed_attribute_values, changed_geometries, ids_deleted))
                
                self.handle_altered_features(layer, list(features.values()))
            except Exception as e:
                self.iface.messageBar().pushMessage("Lagring mislyktes", "" , str(e), level=2, duration=10)

    def lock_feature(self, lyr, changed_feature, references='none'):
        lokalid = changed_feature.attribute('lokalid')
        datasetid = self.dataset_dictionary[lyr.id()]
        crs = lyr.crs().authid()
        crs_epsg = authid_to_code(crs)
        try:
            feature_with_lock = self.client.getDatasetFeatureWithLock(datasetid, lokalid, crs_epsg, references)
            return feature_with_lock
        except Exception as e:
            error = ApiError("Låsing mislyktes", "Kunne ikke låse feature", e)  
            raise Exception(f'{error.title}: {error.show_more}')

    def handle_changed_values(self, lyr, changed_attribute_values, changed_geometries, ids_deleted):
        
        features = {}
        for fid, attributes in changed_attribute_values.items():
            
            if fid in ids_deleted: continue

            changed_feature = lyr.getFeature(fid)
            lokalid = changed_feature.attribute('lokalId')
            if lyr.geometryType() == QgsWkbTypes.PolygonGeometry or lyr.geometryType() == QgsWkbTypes.LineGeometry:
                feature_with_lock = self.lock_feature(lyr, changed_feature, 'direct')
            else:
                feature_with_lock = self.lock_feature(lyr, changed_feature)
            
            for idx, feature in enumerate(feature_with_lock["features"]):
                if feature["properties"]["identifikasjon"]["lokalId"] == lokalid:

                    new_feature = self.feature_to_geojson(lyr, changed_feature)
                    new_feature['update'] = {'action': 'Replace'}
                    
                    if 'geometry_properties' in feature : 
                        new_feature['geometry_properties'] = feature['geometry_properties']
                        #interiors = feature['geometry_properties']['interiors'] if 'interiors' in feature['geometry_properties'] else []
                        #exterior = feature['geometry_properties']['exterior'] if 'exterior' in feature['geometry_properties'] else []
                    features[lokalid] = new_feature
                # If editing line attribute, and there is a feature with geometry_properties set, replace it also (should be polygon)
                elif "geometry_properties" in feature:
                    feature['update'] = {'action': 'Replace'}
                    id = feature["properties"]["identifikasjon"]["lokalId"]
                    features[id] = feature
                else:
                    id = feature["properties"]["identifikasjon"]["lokalId"]
                    features[id] = feature
                    
        
        for fid, geometry in changed_geometries.items():
            
            if fid in ids_deleted: continue

            changed_feature = lyr.getFeature(fid)

            lokalid = changed_feature.attribute('lokalid')
            
            new_geometry = json.loads(geometry.asJson())

            if lokalid in features:
                features[lokalid]['geometry'] = new_geometry
            else:
                # TODO support for delt geometri
                feature_with_lock = self.lock_feature(lyr, changed_feature)

                feature_with_lock['features'][0]['geometry'] = new_geometry
                
                feature_with_lock['features'][0]['update'] = {'action': 'Replace'}
                
                #TODO if key in dict, update only geom

                features.update({ feature['properties']['identifikasjon']['lokalId'] : feature for feature in feature_with_lock["features"] })

        return features

    def handle_committed_features_removed(self, lyr, deleted_features):
        
        features = {}
        for deleted_feature in deleted_features:
            
            feature_with_lock = self.lock_feature(lyr, deleted_feature)
            feature_with_lock['features'][0]['update'] = {'action': 'Erase'}
            
            features.update({ feature['properties']['identifikasjon']['lokalId'] : feature for feature in feature_with_lock["features"] })
        
        return features

    def feature_to_geojson(self, lyr, feature):
        export = QgsJsonExporter(lyr)
        export.setSourceCrs(QgsCoordinateReferenceSystem())
        
        xsd_entry = self.xsd[self.feature_type_dictionary[lyr.id()]]
        feature_json = json.loads(export.exportFeature(feature))
        
        new_feature = {
            "geometry" : feature_json["geometry"]
        }

        properties = {}
        for ele, val in xsd_entry.items():
            
            if ele in feature_json["properties"]:
                value = feature_json["properties"][ele]
                if value is not None:
                    if val.type == "integer":
                        value = int(value)
                    elif val.type == "double":
                        value = float(value)
                    elif val.type == "enum":
                        if val.maxOccurs > 1:
                            value = value[1:-1].split(", ") if len(value[1:-1]) > 0 else []
                        else:
                            val_list = [a["type"] for a in val.values]
                            try:
                                position = val_list.index(value)
                                value = val.values[position]["value"]
                            except Exception:
                                continue

                    if len(val.xmlPath) > 0:
                        # Only one complex-element (maton, 01.11.2022)
                        # if (val.xmlPath[0] == 'identifikasjon' or val.xmlPath[0] == 'kvalitet'):
                        if val.xmlPath[0] in properties:
                            properties[val.xmlPath[0]][ele] = value
                        else:
                            properties[val.xmlPath[0]] = {
                                ele : value
                            }
                        # Assuming multiple complex elements 
                        #else:
                        #    if val.xmlPath[0] in properties:
                        #        properties[val.xmlPath[0]][0][ele] = value
                        #    else:
                        #        properties[val.xmlPath[0]] = [{
                        #            ele : value
                        #        }]
                    else:
                        properties[ele] = value
        
        properties["featuretype"] = self.feature_type_dictionary[lyr.id()]
        new_feature["properties"] = properties
        return new_feature

    def handle_committed_features_added(self, lyr, added_features):
        
        #TODO Husk å committe features som er referert i andre lag så ikke lagre-knappen er mulig å trykke på for allerede innsjekkede features
        
        features = {}
        print(self.xsd)
        for fid, feature in added_features.items():
            
            new_feature = self.feature_to_geojson(lyr, feature)

            lokalid = new_feature["properties"]["identifikasjon"]["lokalId"]
            
            if lokalid in self.affected_features:
                #Har kommet fra felleskomponent, skal ha id allerede, må derfor ikke autogenerere ny id her
                featureFromFelleskomponent = self.affected_features[lokalid]
                new_feature['geometry_properties'] = featureFromFelleskomponent['geometry_properties']
                new_feature['update'] = featureFromFelleskomponent['update']

                exterior = new_feature['geometry_properties'].get('exterior', [])
                interior = new_feature['geometry_properties'].get('interior', [])

                references = exterior + interior

                layers = QgsProject.instance().mapLayers()

                for reference in references:
                    done = False
                    if reference not in self.affected_features:
                        raise Exception("Not yet implemented, uncertain if this is a use case")
                    
                    affected_feature = self.affected_features[reference]

                    for layer_id, layer in layers.items():
                        if done:
                            break
                        else:
                            if layer.editBuffer() is not None:
                                print("ok")
                                addedFeaturesInThisLayer = list(layer.editBuffer().addedFeatures().values())
                                for added_feature in addedFeaturesInThisLayer:
                                    affectedGeojsonFeature = self.feature_to_geojson(layer, added_feature)
                                    affectedLokalid = affectedGeojsonFeature["properties"]["identifikasjon"]["lokalId"]
                                    
                                    if affectedLokalid == reference:
                                        #We found referenced geometry in another layer
                                        
                                        geometryProperties = affected_feature.get('geometry_properties', None)
                                        if geometryProperties is not None:
                                            affectedGeojsonFeature['geometry_properties'] = affected_feature['geometry_properties']

                                        affectedGeojsonFeature['update'] = affected_feature['update']
                                        
                                        features[reference] = affectedGeojsonFeature
                                        done = True
                                        break

                features[lokalid] = new_feature

                    

                



            else:
                lokalid = str(uuid.uuid4())
                new_feature["properties"]["identifikasjon"]["lokalId"] = lokalid
                lyr.updateFeature(feature)
                new_feature['update'] = {"action":"Create"}
                features[lokalid] = new_feature
            
            # Update QGIS layer with new uuid, must be string (not json)
            feature.setAttribute('lokalid', lokalid)
            

        return features

    def handle_altered_features(self, lyr, features):
       
        try:

            if len(features) == 0:
                self.iface.messageBar().pushMessage("Success", "Ingen endringer ble sjekket inn i NGIS-OpenAPI", level=3, duration=3)
                return

            json_dict = {"type": "FeatureCollection", "features" : None, "crs" : None}
            
            crs = lyr.crs().authid()
            crs_epsg = authid_to_code(crs)
            json_dict.update(create_crs_entry(crs))
            json_dict['features'] = features

            datasetid = self.dataset_dictionary[lyr.id()]
            return_data = self.client.updateDatasetFeature(datasetid, crs_epsg, json_dict)
            self.iface.messageBar().pushMessage("Success", f"{lyr.name()}: Endringene er lagret", str(return_data), level=3, duration=10)
            
        except Exception as e:
            error = ApiError("Lagring mislyktes", "Kunne ikke lagre endringene", e)
            self.iface.messageBar().pushMessage(error.title, error.detail, error.show_more, level=2, duration=10)
            return

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        if self.first_start == True:
            self.first_start = False
            # Get previous login method if any
            s = QgsSettings()
            auth_method_id = s.value("ngisopenapi/auth_method_id", "")
            #keep a modeless dialog window on top of the main QGIS window.
            self.dlg = NgisOpenApiClientDialog(self.iface.mainWindow())
            self.dlg.mAuthConfigSelect.setConfigId(auth_method_id)
            self.dlg.logInButton.clicked.connect(self.handle_login)
            self.dlg.logOutButton.clicked.connect(self.handle_logout)
            self.dlg.addLayerButton.clicked.connect(self.handle_add_layer)
            
        # show the dialog
        self.dlg.show()