# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NgisOpenApiClient
                                 A QGIS plugin
 Plugin for nedlasting av data fra NGIS OpenAPI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-10-26
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Norconsult Informasjonssystemer AS
        email                : post@nois.no
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QTextCodec, QDate, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QPushButton, QMessageBox, QInputDialog
from qgis.utils import plugins
from qgis.core import (
    QgsProject,
    QgsPathResolver,
    QgsVectorLayer,
    QgsOgcUtils,
    QgsFeature,
    QgsJsonUtils,
    QgsJsonExporter,
    QgsAuthManager,
    QgsWkbTypes,
    QgsSettings,
    QgsDefaultValue,
    QgsFieldConstraints,
    QgsEditorWidgetSetup,
    QgsCoordinateReferenceSystem,
    QgsMessageLog,
    QgsFeatureRequest,
    QgsProcessingContext,
    QgsTaskManager,
    QgsTask,
    QgsProcessingAlgRunnerTask,
    Qgis,
    QgsProcessingFeedback,
    QgsApplication,
    QgsMessageLog,
    QgsField,
    QgsGeometry,
    QgsVectorLayerUtils
)


import json
import uuid
from .login import NgisOpenApiClientAuthentication
from .http_client import NgisHttpClient
import requests
from .ngis_openapi_client_aux import *
from .ngis_openapi_client_xsd_parser import *
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ngis_openapi_client_dialog import NgisOpenApiClientDialog
from .ngis_openapi_client_input_dialog import NgisInputTypeDialog
from xml.dom import minidom
import os.path
import re
from osgeo import ogr


class NgisOpenApiClient:
    """QGIS Plugin Implementation."""
    
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'NgisOpenApiClient_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NGIS-OpenAPI')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.dataset_dictionary = {}
        self.feature_type_dictionary = {}
        self.selected_features_dictionary = {}
        self.layer_dictionary = {}
        self.affected_features = {}
        self.affected_features_to_layer = {}
        self.client = None
        self.xsd = []
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('NgisOpenApiClient', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ngis_openapi_client/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'NGIS-OpenAPI Test'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NGIS-OpenAPI Test'),
                action)
            self.iface.removeToolBarIcon(action)

    def handle_login(self):
        auth = NgisOpenApiClientAuthentication()
        configId = self.dlg.mAuthConfigSelect.configId()
        url, username, password = auth.getConfig(configId)
        if not username:
            self.dlg.statusLabel.setText("Autentisering mislyktes")
            return
        self.client = NgisHttpClient(url, username, password) 

        try:
            datasets = self.client.getAvailableDatasets()
        except Exception as e:
            error = ApiError("Kunne ikke hente datasett", "Utlisting av datasett resulterte i en feil", e)  
            self.iface.messageBar().pushMessage(error.title, error.detail, error.show_more, level=2, duration=10)
            return 
        
        if len(datasets) == 0:
            self.dlg.statusLabel.setText("Ingen datasett tilgjengelig")
            return
        
        self.dataset_dictionary = {dataset["name"]:dataset["id"] for dataset in datasets}
        
        names = [dataset['name'] for dataset in datasets]
        self.dlg.mComboBox.addItems(names)

        self.dlg.mComboBox.setEnabled(True)
        self.dlg.logInButton.setEnabled(False)
        self.dlg.logOutButton.setEnabled(True)
        self.dlg.addLayerButton.setEnabled(True)
        self.dlg.mAuthConfigSelect.setEnabled(False)
        self.dlg.statusLabel.setText("")
        # Remember login method
        s = QgsSettings()
        s.setValue("ngisopenapi/auth_method_id", configId)
        return

    def handle_logout(self):
        self.dlg.mComboBox.clear()
        self.dlg.logInButton.setEnabled(True)
        self.dlg.logOutButton.setEnabled(False)
        self.dlg.addLayerButton.setEnabled(False)
        self.dlg.mAuthConfigSelect.setEnabled(True)
        self.dlg.mComboBox.setEnabled(False)
        self.client = None

    def create_group(self, name):
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(name)
        if not group:
            group = root.insertGroup(0, name)
        return group

    def handle_make_polygon_from_line(self):
        
        features = []

        for layer_id, fids in self.selected_features_dictionary.items():

            lineLayer = QgsProject.instance().mapLayers()[layer_id]

            for fid in fids:
            
                line_feature = lineLayer.getFeature(fid)
                new_feature = self.feature_to_geojson(lineLayer, line_feature)

                features.append(new_feature)

        if len(features) == 0: return

        url = 'https://ngis-felleskomponent-test.azurewebsites.net/polygonFromLines'
        
        body = {'features': features}

        x = requests.post(url, json = body)

        topology_responses = json.loads(x.text)

        added_polygons = {}

        for topology_response in topology_responses:

            for feature in topology_response["affectedFeatures"]:
                action = feature.get("update", {}).get("action", None)
                if action is not None:
                    # Felleskomponenten endrer ikke status på uberørte features. Hvis de er endret tidligere men ikke i denne transaksjonen beholder de sin status.
                    added_polygons[feature['properties']['identifikasjon']['lokalId']] = feature
                
                # Legger inn alle affected features fra felleskomponenten, disse trengs ved innsjekk til NGIS-OpenAPI #TODO CONFIRM   
                self.affected_features[feature['properties']['identifikasjon']['lokalId']] = feature

        for lokalid, feature in added_polygons.items():
            options = list(self.feature_type_dictionary.values())
            self.prompt_new_feature(feature, options)

        print(len(lineLayer))


    def handle_add_layer(self):
        """Create a new layer by name (rev_lyr)"""

        slds = self.get_sld()

        selected_name = self.dlg.mComboBox.currentText()
        selected_id = self.dataset_dictionary[selected_name]
        
        # Group name equals selected dataset name
        group_kodelister = self.create_group("Kodelister")
        group_kodelister.setExpanded(0)
        group = self.create_group(selected_name)
        

        # Get metadata and features from NgisOpenAPI
        try:
            metadata_from_api = self.client.getDatasetMetadata(selected_id)

            #resp = requests.get(metadata_from_api.schema_url)
            resp = requests.get('http://skjema.geonorge.no/SOSI/produktspesifikasjon/Havnedata/2.0/Havnedata.xsd', verify=False)
            #resp = requests.get('https://havnedata.blob.core.windows.net/skjema/Havnedata_testdemo.xsd', verify=False)

            self.xsd = parseXSD(resp.content)
            #raise Exception()
            #metadata_from_api.bbox['ur'] = [336509.55, 6578691.58]
            #metadata_from_api.bbox['ll']=[270083.13, 6522356.34]

            epsg = metadata_from_api.crs_epsg
            features_from_api = self.client.getDatasetFeatures(metadata_from_api.id, metadata_from_api.bbox, epsg)
        except Exception as e:
            error = ApiError("Nedlasting av data mislyktes", "Kunne ikke laste ned datasett", e)  
            self.iface.messageBar().pushMessage(error.title, error.detail, error.show_more, level=2, duration=10)
            return 
        crs_from_api = features_from_api['crs']['properties']['name']
        features_by_type = {}
        
        # Extract features from GeoJSON into dictionary
        for feature in features_from_api['features']:
            feature_type = feature['properties']['featuretype']
            features_by_type.setdefault(feature_type, []).append(feature)
        
        features_from_api['features'] = None



        for typeNavn, typeVerdi in self.xsd.items():
            for attrNavn, attrVerdi in typeVerdi.items():
                if (attrVerdi.type == 'enum' and attrVerdi.maxOccurs > 1):
                    vector_names = [l.name() for l in QgsProject().instance().mapLayers().values() if isinstance(l, QgsVectorLayer)]
                    if attrNavn in vector_names: continue

                    lyr = QgsVectorLayer('NoGeometry?crs=EPSG:4326&field=Verdi:string(40,0)', f'{attrNavn}', "memory")
                    lyr.setCustomProperty("skipMemoryLayersCheck", 1) #13012022
                    lyr.startEditing()
                    l_d = lyr.dataProvider()
                    fields = QgsFields()
                    fields.append(QgsField('Verdi', QVariant.String, '', 254, 0))
                    
                    for val in attrVerdi.values:
                        fet = QgsFeature()
                        fet.setFields(fields)
                        fet['Verdi']=val['value']
                        l_d.addFeature(fet)


                    lyr.commitChanges()
                    QgsProject.instance().addMapLayer(lyr, False)
                    group_kodelister.addLayer(lyr)
        layers = {}                    

        for feature_type, features_list in features_by_type.items():
            # Create a new GeoJSON object containing a single featuretype
            features_dict = features_from_api.copy()
            features_dict['features'] = features_list

            features_json = json.dumps(features_dict, ensure_ascii=False) 
            
            # Identify fields and features from GeoJSON
            codec = QTextCodec.codecForName("UTF-8")   
            fields = QgsJsonUtils.stringToFields(features_json, codec)
            newFeatures = QgsJsonUtils.stringToFeatureList(features_json, fields, codec)

            # If different geometry types are identified, separate them into individual layers
            geometry_dict = {}
            if newFeatures:   
                for feature in newFeatures:

                    featuretype = feature.attribute('featuretype')
                    geom_type = feature.geometry()
                    geom_type = QgsWkbTypes.displayString(int(geom_type.wkbType()))
                    if geom_type not in geometry_dict:
                        geometry_dict[geom_type] = {}
                    if featuretype not in geometry_dict[geom_type]:
                        geometry_dict[geom_type][featuretype] = []
                    
                    geometry_dict[geom_type][featuretype].append(feature)

            for geom_type, feature_types in geometry_dict.items():
                for feature_type, features in feature_types.items():
                    lyr = QgsVectorLayer(f'{geom_type}?crs={crs_from_api}', f'{feature_type}-{geom_type}', "memory")
                    #lyr = QgsVectorLayer(f'{geom_type}?crs=EPSG:25832', f'{feature_type}-{geom_type}', "memory") #TODO Remove
                    QgsProject.instance().addMapLayer(lyr, False)
                    
                    lyr.startEditing()
                    
                    add_fields_to_layer(lyr, fields, feature_type, self.xsd)
                    print(f'{geom_type}?crs={crs_from_api}', f'{feature_type}-{geom_type}')   
                    lyr.commitChanges()
                    l_d = lyr.dataProvider()
                    lyrfields = lyr.fields()

                    for feature in features:
                        fet = QgsFeature()
                        fet.setGeometry(feature.geometry())

                        attributes = feature.attributes()
                        newDict = {}
                        for idx, attribute in enumerate(attributes):
                            xsd_def = self.xsd[feature_type].get(fields.at(idx).name(), None)
                            
                            oldfield = fields.at(idx)
                            if xsd_def and feature.attributes()[idx] != None and xsd_def.type == "enum" and xsd_def.maxOccurs > 1:
                                vals = feature.attributes()[idx][3:-1].split(",")
                                vals = ','.join(vals)
                                newDict[oldfield.name()] = f'{{{vals}}}'


                            else:
                                try:
                                    obj = json.loads(attribute)
                                    for key, value in obj.items():
                                        newDict[key] = value
                                except:
                                    newDict[oldfield.name()] = feature.attributes()[idx]

                        fieldOrder = {}
                        fet.initAttributes(len(lyrfields))
                        for fieldName in newDict.keys():
                            newIdx = lyrfields.indexFromName(fieldName)
                            fieldOrder[fieldName] = newIdx
                            print(f'{newIdx} - {newDict[fieldName]}')
                            try:
                                fet.setAttribute(newIdx, newDict[fieldName])
                            except Exception as e:
                                print(e)
                        l_d.addFeature(fet)

                    
                    # update the extent of rev_lyr
                    lyr.updateExtents()
                    # save changes made in 'rev_lyr'
                    lyr.commitChanges()
                    layers[lyr.name()] = lyr
                    
                   
                    #lyr.committedFeaturesAdded.connect(self.handleCommitedAddedFeatures)
                    #lyr.committedFeaturesRemoved.connect(self.handleCommittedFeaturesRemoved)
                    #lyr.featuresDeleted.connect(self.handleDeletedFeatures)
                    #lyr.committedGeometriesChanges(self.ee)
                    
                    self.layer_dictionary[lyr.id()] = lyr

                    lyr.beforeCommitChanges.connect(self.handle_before_commitchanges)
                    lyr.featureAdded.connect(self.handle_feature_added)
                    #Legge inn disse i en array, eller loope igjennom alle lag etter uncommited features?
                    lyr.geometryChanged.connect(self.handle_geometry_change)
                    lyr.selectionChanged.connect(self.handle_selection_change)

                    if feature_type in slds:
                        lyr.loadSldStyle(slds[feature_type])

                    self.dataset_dictionary[lyr.id()] = selected_id
                    self.feature_type_dictionary[lyr.id()] = feature_type
            
        for layername in sorted(list(layers.keys())):
            group.addLayer(layers[layername])

    def get_sld(self):
        sld_dict = {}
        folder_name = f"{os.path.dirname(__file__)}/styles"
        for filename in os.listdir(folder_name):
            full_path = f"{folder_name}/{filename}"
            sld = minidom.parse(full_path)
            styled_layer_descriptor = sld.getElementsByTagName('StyledLayerDescriptor')
            if len(styled_layer_descriptor) == 1:
                named_layers = styled_layer_descriptor[0].getElementsByTagName('NamedLayer')
                for named_layer in named_layers:
                    for child in named_layer.childNodes:
                        if child.localName == "Name":
                            name = child.firstChild.nodeValue
                            sld_dict[name] = full_path
                            break
        return sld_dict

    def is_valid_uuid(self, value):
        try:
            uuid.UUID(str(value))

            return True
        except ValueError:
            return False

    def handle_feature_added(self, fid):

        #ignore commited features
        if fid > 0: 
            return

        #identify which layer this feature is temporary saved in
        added_feature = None
        layer = None

        for layerName, layerObject in QgsProject.instance().mapLayers().items():
            if layerObject.getFeature(fid).isValid():
                added_feature = layerObject.getFeature(fid)
                layer = layerObject
                break
        #ignore features not found in any layer, should not happen
        if added_feature is None:
            return

        lokalid = added_feature["lokalid"]
        if not self.is_valid_uuid(lokalid):
            lokalid = str(uuid.uuid4())
            added_feature.setAttribute('lokalid', lokalid)
            layer.updateFeature(added_feature)

        if lokalid in self.affected_features:
            return


        #Polygon
        if added_feature.geometry().type() == 2:
            new_feature = self.feature_to_geojson(layer, added_feature)
            new_feature['update'] = {"action":"Create"}

            new_feature["properties"]["identifikasjon"]["lokalId"] = lokalid

            url = 'https://ngis-felleskomponent-test.azurewebsites.net/createGeometry'
            body = {'feature': new_feature}

            x = requests.post(url, json = body)

            affected_features = json.loads(x.text)

            for feature in affected_features["affectedFeatures"]:
                self.affected_features[feature['properties']['identifikasjon']['lokalId']] = feature

            #TODO Fix
            avgrensing_feature = affected_features["affectedFeatures"][1]

            options = list(self.feature_type_dictionary.values())

            self.prompt_new_feature(avgrensing_feature, options)
            

    def prompt_new_feature(self, feature_geojson, prompt_options):
        
        dialog = NgisInputTypeDialog(prompt_options)

        if dialog.ok:
            layerName = next(key for key, value in self.feature_type_dictionary.items() if value == dialog.item)
            lineLayer = QgsProject.instance().mapLayers()[layerName]
            
            # Create feature in map and open attribute form
            return self.create_new_feature_with_attribute_form(lineLayer, feature_geojson)

    def create_new_feature_with_attribute_form(self, lyr, feature_geojson):
        
        lyr.startEditing()

        geom = ogr.CreateGeometryFromJson(json.dumps(feature_geojson['geometry']))
        geom = QgsGeometry.fromWkt(geom.ExportToWkt())

        dataProvider = lyr.dataProvider()

        feat = QgsVectorLayerUtils.createFeature(lyr, geom, {}, lyr.createExpressionContext() )

        
        feat.setAttribute('lokalid', feature_geojson['properties']['identifikasjon']['lokalId'])
        lyr.updateFeature(feat)

        tbl = self.iface.openFeatureForm(lyr, feat, False)
        if tbl == True:
            dataProvider.addFeature(feat)
            lyr.endEditCommand()
        
        lyr.addFeature(feat)
        return lyr, feat

    def find_ngis_feature_in_canvas(self, ngis_feature):
        lokalid = ngis_feature.get("properties", {}).get("identifikasjon", {}).get("lokalId", None)
        featureType = ngis_feature.get("properties", {}).get("featuretype", None)
        for layerId, featureTypeName in self.feature_type_dictionary.items():
            if featureTypeName == featureType:
                matchLayer = self.layer_dictionary[layerId]
                features_in_layer = matchLayer.getFeatures()
                for layerFeature in features_in_layer:
                    if layerFeature["lokalid"] == lokalid:
                        print(f"fant {lokalid} in {matchLayer.id()}, {layerFeature.geometry().type()}")
                        return matchLayer, layerFeature

    def handle_geometry_change(self, fid, geometry):
        print("geometryChanged")
        
        layers = QgsProject.instance().mapLayers()

        for layer_id, layer in layers.items():
            if not isinstance(layer, QgsVectorLayer): continue

            editBuffer = layer.editBuffer()
            if editBuffer is not None:
                changed_geometries = editBuffer.changedGeometries()
                if fid in changed_geometries and geometry.asJson() == changed_geometries[fid].asJson():
                    #Feature identified in layer, TODO must be a better way to do this
                    new_feature = layer.getFeature(fid)
                    old_feature = list(layer.dataProvider().getFeatures( QgsFeatureRequest( fid ) ))[0]
                    ngis_openapi_result = self.lock_feature(layer, old_feature, 'direct')
                    referenced_features = []
                    feature_from_ngis_openapi = ngis_openapi_result.get("features", [])
                    for feature in feature_from_ngis_openapi:
                        canvas_lyr, feature_in_canvas = self.find_ngis_feature_in_canvas(feature)
                        feature_in_canvas_json = self.feature_to_geojson(canvas_lyr, feature_in_canvas)
                        
                        geometry_properties = feature.get("geometry_properties", None)
                        if geometry_properties is not None:
                            feature_in_canvas_json["geometry_properties"] = geometry_properties

                        referenced_features.append(feature_in_canvas_json)

                    url = 'https://ngis-felleskomponent-test.azurewebsites.net/editLine'
        
                    body = {
                        'feature': self.feature_to_geojson(layer, old_feature),
                        'newFeature': self.feature_to_geojson(layer, new_feature),
                        'affectedFeatures' : referenced_features
                        }
                    
                    x = requests.post(url, json = body)
            
                    topology_response = json.loads(x.text)

                    affected_features = topology_response.get("affectedFeatures", [])

                    #TODO add to self.affected
                    features_to_be_replaced = []
                    for feature in affected_features:
                        lokalid = feature.get("properties", {}).get("identifikasjon", {}).get("lokalId", None)
                        action = feature.get("update", {}).get("action", None)
                        if action == "Replace":
                            features_to_be_replaced.append(feature)
                        self.affected_features[lokalid] = feature

                    for featurePendingReplacement in features_to_be_replaced:
                        lokalid = featurePendingReplacement.get("properties", {}).get("identifikasjon", {}).get("lokalId", None)
                        featureType = featurePendingReplacement.get("properties", {}).get("featuretype", None)
                        new_geometry = featurePendingReplacement.get("geometry", None)
                        
                        for layerId, featureTypeName in self.feature_type_dictionary.items():
                            if featureTypeName == featureType:
                                matchLayer = self.layer_dictionary[layerId]
                                features_in_layer = matchLayer.getFeatures()

                                for layerFeature in features_in_layer:
                                    geom = layerFeature.geometry()
                                    if layerFeature["lokalid"] == lokalid:
                                        
                                        matchLayer.geometryChanged.disconnect(self.handle_geometry_change)
                                        matchLayer.startEditing()
                                        geom = ogr.CreateGeometryFromJson(json.dumps(new_geometry))
                                        geom = QgsGeometry.fromWkt(geom.ExportToWkt())
                                        layerFeature.setGeometry(geom)
                                        matchLayer.updateFeature(layerFeature)
                                        matchLayer.geometryChanged.connect(self.handle_geometry_change)
                                        break
                                        print("Found feature to replace geometry")

                    
                    print(f"layer: {layer.id()}, fid: {fid}")

            #print(f"layer: {layer.id()}, fid: {fid}")
            #added_feature = layer.getFeature(fid)

    def handle_selection_change(self, selected_fids, deselected_fids, clear_and_select):
        layer = self.iface.activeLayer()
        print(f"selectionChanged! Layer: {layer.name(),}, Selected: {selected_fids}, Deselected: {deselected_fids}, ClearAndSelect: {clear_and_select}" )

        if not clear_and_select:
            raise Exception("ClearAndSelect == False - Not implemented")
        
        #feature_type_name = self.feature_type_dictionary[layer.id()]
        
        self.selected_features_dictionary[layer.id()] = selected_fids
        
        fid_count = 0
        for fid_list in self.selected_features_dictionary.values():
            fid_count += len(fid_list)

        if fid_count > 0:
            self.dlg.polyFromLineButton.setEnabled(True)
        else:
            self.dlg.polyFromLineButton.setEnabled(False)


    def handle_before_commitchanges(self):
        
        layer = self.iface.activeLayer()

        if layer.editBuffer():
            ids_deleted = layer.editBuffer().deletedFeatureIds()
            features_deleted = layer.dataProvider().getFeatures(QgsFeatureRequest().setFilterFids(ids_deleted))
            features_added = layer.editBuffer().addedFeatures()
            changed_geometries = layer.editBuffer().changedGeometries()
            changed_attribute_values = layer.editBuffer().changedAttributeValues()

            try:
                features = {}
                features.update(self.handle_committed_features_removed(layer, features_deleted))
                features.update(self.handle_committed_features_added(layer, features_added))
                features.update(self.handle_changed_values(layer, changed_attribute_values, changed_geometries, ids_deleted))
                
                #TODO CLEAN UP AFFECTED FEATURES

                self.handle_altered_features(layer, list(features.values()))
            except Exception as e:
                self.iface.messageBar().pushMessage("Lagring mislyktes", "" , str(e), level=2, duration=10)

    def lock_feature(self, lyr, changed_feature, references='none'):
        lokalid = changed_feature.attribute('lokalid')
        datasetid = self.dataset_dictionary[lyr.id()]
        crs = lyr.crs().authid()
        crs_epsg = authid_to_code(crs)
        try:
            feature_with_lock = self.client.getDatasetFeatureWithLock(datasetid, lokalid, crs_epsg, references)
            return feature_with_lock
        except Exception as e:
            error = ApiError("Låsing mislyktes", "Kunne ikke låse feature", e)  
            raise Exception(f'{error.title}: {error.show_more}')

    def handle_changed_values(self, lyr, changed_attribute_values, changed_geometries, ids_deleted):
        
        features = {}
        for fid, attributes in changed_attribute_values.items():
            
            if fid in ids_deleted: continue

            changed_feature = lyr.getFeature(fid)

            if not changed_feature.isValid(): continue

            lokalid = changed_feature.attribute('lokalId')
            if lyr.geometryType() == QgsWkbTypes.PolygonGeometry or lyr.geometryType() == QgsWkbTypes.LineGeometry:
                feature_with_lock = self.lock_feature(lyr, changed_feature, 'direct')
            else:
                feature_with_lock = self.lock_feature(lyr, changed_feature)
            
            for idx, feature in enumerate(feature_with_lock["features"]):
                if feature["properties"]["identifikasjon"]["lokalId"] == lokalid:

                    new_feature = self.feature_to_geojson(lyr, changed_feature)
                    new_feature['update'] = {'action': 'Replace'}
                    
                    if 'geometry_properties' in feature : 
                        new_feature['geometry_properties'] = feature['geometry_properties']
                        #interiors = feature['geometry_properties']['interiors'] if 'interiors' in feature['geometry_properties'] else []
                        #exterior = feature['geometry_properties']['exterior'] if 'exterior' in feature['geometry_properties'] else []
                    features[lokalid] = new_feature
                # If editing line attribute, and there is a feature with geometry_properties set, replace it also (should be polygon)
                elif "geometry_properties" in feature:
                    feature['update'] = {'action': 'Replace'}
                    id = feature["properties"]["identifikasjon"]["lokalId"]
                    features[id] = feature
                else:
                    id = feature["properties"]["identifikasjon"]["lokalId"]
                    features[id] = feature
                    
        
        for fid, geometry in changed_geometries.items():
            
            if fid in ids_deleted: continue

            changed_feature = lyr.getFeature(fid)

            lokalid = changed_feature.attribute('lokalid')
            
            new_geometry = json.loads(geometry.asJson())

            if lokalid in features:
                features[lokalid]['geometry'] = new_geometry
            else:
                # TODO support for delt geometri
                feature_with_lock = self.lock_feature(lyr, changed_feature)

                feature_with_lock['features'][0]['geometry'] = new_geometry
                
                feature_with_lock['features'][0]['update'] = {'action': 'Replace'}
                
                #TODO if key in dict, update only geom

                features.update({ feature['properties']['identifikasjon']['lokalId'] : feature for feature in feature_with_lock["features"] })

        return features

    def handle_committed_features_removed(self, lyr, deleted_features):
        
        features = {}
        for deleted_feature in deleted_features:
            
            feature_with_lock = self.lock_feature(lyr, deleted_feature)
            feature_with_lock['features'][0]['update'] = {'action': 'Erase'}
            
            features.update({ feature['properties']['identifikasjon']['lokalId'] : feature for feature in feature_with_lock["features"] })
        
        return features

    def feature_to_geojson(self, lyr, feature):
        export = QgsJsonExporter(lyr)
        export.setSourceCrs(QgsCoordinateReferenceSystem())
        
        xsd_entry = self.xsd[self.feature_type_dictionary[lyr.id()]]
        feature_json = json.loads(export.exportFeature(feature))
        
        new_feature = {
            "geometry" : feature_json["geometry"]
        }

        properties = {}
        for ele, val in xsd_entry.items():
            
            if ele in feature_json["properties"]:
                value = feature_json["properties"][ele]
                if value is not None:
                    if val.type == "integer":
                        value = int(value)
                    elif val.type == "double":
                        value = float(value)
                    elif val.type == "enum":
                        if val.maxOccurs > 1:
                            value = value[1:-1].split(", ") if len(value[1:-1]) > 0 else []
                        else:
                            val_list = [a["type"] for a in val.values]
                            try:
                                position = val_list.index(value)
                                value = val.values[position]["value"]
                            except Exception:
                                continue

                    if len(val.xmlPath) > 0:
                        if val.xmlPath[0] in properties:
                            properties[val.xmlPath[0]][ele] = value
                        else:
                            properties[val.xmlPath[0]] = {
                                ele : value
                            }
                    else:
                        properties[ele] = value
        
        properties["featuretype"] = self.feature_type_dictionary[lyr.id()]
        new_feature["properties"] = properties
        return new_feature

    def handle_committed_features_added(self, lyr, added_features):
        
        #TODO Husk å committe features som er referert i andre lag så ikke lagre-knappen er mulig å trykke på for allerede innsjekkede features
        
        features = {}
        print(self.xsd)
        for fid, feature in added_features.items():
            
            new_feature = self.feature_to_geojson(lyr, feature)

            lokalid = new_feature["properties"]["identifikasjon"]["lokalId"]
            
            if lokalid in self.affected_features:
                #Har kommet fra felleskomponent, skal ha id allerede, må derfor ikke autogenerere ny id her
                featureFromFelleskomponent = self.affected_features[lokalid]
                new_feature['geometry_properties'] = featureFromFelleskomponent['geometry_properties']
                new_feature['update'] = featureFromFelleskomponent['update']

                exterior = new_feature['geometry_properties'].get('exterior', [])
                interior = new_feature['geometry_properties'].get('interior', [])

                references = exterior + interior

                layers = QgsProject.instance().mapLayers()

                for reference in references:
                    # Ignore direction when searching for references
                    if reference[0] == '-':
                        reference = reference[1:]

                    done = False
                    if reference not in self.affected_features:
                        raise Exception("Not yet implemented, uncertain if this is a use case")


                    affected_feature = self.affected_features[reference]

                    features[reference] = affected_feature

                    for layer_id, layer in layers.items():
                        if done:
                            break
                        else:
                            if isinstance(layer, QgsVectorLayer) and layer.editBuffer() is not None:
                                # Informasjon fra bufferlag har prioritet over felleskomponenten, kan ha skjedd ting i mellomtiden
                                print("ok")
                                addedFeaturesInThisLayer = list(layer.editBuffer().addedFeatures().values())
                                for added_feature in addedFeaturesInThisLayer:
                                    affectedGeojsonFeature = self.feature_to_geojson(layer, added_feature)
                                    affectedLokalid = affectedGeojsonFeature["properties"]["identifikasjon"]["lokalId"]
                                    
                                    if affectedLokalid == reference:
                                        #We found referenced geometry in another layer
                                        
                                        geometryProperties = affected_feature.get('geometry_properties', None)
                                        if geometryProperties is not None:
                                            affectedGeojsonFeature['geometry_properties'] = affected_feature['geometry_properties']

                                        affectedGeojsonFeature['update'] = affected_feature['update']
                                        
                                        features[reference] = affectedGeojsonFeature
                                        done = True
                                        break

                features[lokalid] = new_feature

                    

                



            else:


                #lokalid = str(uuid.uuid4())
                #new_feature["properties"]["identifikasjon"]["lokalId"] = lokalid
                #lyr.updateFeature(feature)
                new_feature['update'] = {"action":"Create"}
                features[lokalid] = new_feature
            
            # Update QGIS layer with new uuid, must be string (not json)
            feature.setAttribute('lokalid', lokalid)
            

        return features

    def handle_altered_features(self, lyr, features):
       
        try:

            if len(features) == 0:
                self.iface.messageBar().pushMessage("Success", "Ingen endringer ble sjekket inn i NGIS-OpenAPI", level=3, duration=3)
                return

            json_dict = {"type": "FeatureCollection", "features" : [], "crs" : None}
            
            crs = lyr.crs().authid()
            crs_epsg = authid_to_code(crs)
            json_dict.update(create_crs_entry(crs))
            
            lokalids = set()
            for feature in features: 
                lokalid = feature.get("properties", {}).get("identifikasjon", {}).get("lokalId", None)
                lokalids.add(lokalid)

            for affected_lokalid, affected_feature in self.affected_features.items():
                if not affected_lokalid in lokalids:
                    features.append(affected_feature)

            json_dict['features'] = features


            datasetid = self.dataset_dictionary[lyr.id()]
            return_data = self.client.updateDatasetFeature(datasetid, crs_epsg, json_dict)

            # TODO Smarter filtering of which features was necessary, and which affected_features has not yet been commited
            self.affected_features = {}

            self.iface.messageBar().pushMessage("Success", f"{lyr.name()}: Endringene er lagret", str(return_data), level=3, duration=10)
            
        except Exception as e:
            error = ApiError("Lagring mislyktes", "Kunne ikke lagre endringene", e)
            self.iface.messageBar().pushMessage(error.title, error.detail, error.show_more, level=2, duration=10)
            return

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        if self.first_start == True:
            self.first_start = False
            # Get previous login method if any
            s = QgsSettings()
            auth_method_id = s.value("ngisopenapi/auth_method_id", "")
            #keep a modeless dialog window on top of the main QGIS window.
            self.dlg = NgisOpenApiClientDialog(self.iface.mainWindow())
            self.dlg.mAuthConfigSelect.setConfigId(auth_method_id)
            self.dlg.logInButton.clicked.connect(self.handle_login)
            self.dlg.logOutButton.clicked.connect(self.handle_logout)
            self.dlg.addLayerButton.clicked.connect(self.handle_add_layer)
            self.dlg.polyFromLineButton.clicked.connect(self.handle_make_polygon_from_line)

        # show the dialog
        self.dlg.show()